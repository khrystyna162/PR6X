# Звіт з лабораторної роботи №6
## Тема: Впровадження механік аутентифікації та авторизації для API

## Виконав: [Ваше ім'я]
## Група: [Група]
## Дата: 24.11.2025

---

## 1. Опис реалізованої логіки та структури проекту

### Структура проекту

```
lab6/
├── src/
│   ├── domain/              # Доменний шар
│   │   ├── User.js          # Сутність User (id, username, passwordHash, createdAt)
│   │   └── Session.js       # Сутність Session (id, userId, expiresAt, createdAt)
│   │
│   ├── repositories/        # Репозиторії для роботи з даними
│   │   ├── database.js      # In-memory БД (для спрощення)
│   │   ├── UserRepository.js    # Створення користувачів, перевірка паролів
│   │   └── SessionRepository.js # Створення/видалення сесій
│   │
│   ├── routes/              # API роути
│   │   ├── auth.js          # Роути автентифікації
│   │   └── resources.js     # Приклад захищених ресурсів
│   │
│   ├── schemas/             # JSON Schema для валідації
│   │   └── authSchemas.js   # Схеми для register, login, info, logout
│   │
│   ├── plugins/             # Fastify плагіни
│   │   └── auth.js          # Плагін автентифікації
│   │
│   └── index.js             # Головний файл додатку
│
├── nginx/
│   └── nginx.conf           # Конфігурація Nginx з Basic Auth
├── package.json             # Залежності проекту
├── generate-htpasswd.js     # Скрипт генерації паролів для Nginx
├── test-api.js              # Тестовий скрипт
└── README.md                # Документація
```

### Реалізовані компоненти

#### 1. Сутності (Domain Layer)

**User.js** - представляє користувача системи:
- `id` - унікальний ідентифікатор
- `username` - ім'я користувача (унікальне)
- `passwordHash` - хеш пароля (bcrypt)
- `createdAt` - дата створення

**Session.js** - представляє сесію користувача:
- `id` - унікальний ідентифікатор сесії (64-символьний hex)
- `userId` - ID користувача
- `expiresAt` - дата закінчення сесії
- `createdAt` - дата створення
- `isExpired()` - метод перевірки чи сесія протермінована

#### 2. Репозиторії (Data Layer)

**UserRepository** - управління користувачами:
- `create(username, password)` - створення користувача з хешуванням пароля
- `findByUsername(username)` - пошук користувача за іменем
- `findById(id)` - пошук користувача за ID
- `verifyPassword(user, password)` - перевірка пароля

**SessionRepository** - управління сесіями:
- `create(userId, expiresInHours)` - створення нової сесії
- `findById(id)` - пошук сесії за ID
- `delete(id)` - видалення сесії
- `deleteExpired()` - очищення протермінованих сесій

#### 3. API Роути

**Автентифікація** (`/auth/*`):
- `POST /auth/register` - реєстрація нового користувача
- `POST /auth/login` - вхід (створення сесії та cookie)
- `GET /auth/info` - інформація про користувача (захищено)
- `POST /auth/logout` - вихід (видалення сесії)

**Приклад захищених ресурсів** (`/resources`):
- `GET /resources` - публічний доступ (READ)
- `POST /resources` - захищено (CREATE)
- `PUT /resources/:id` - захищено (UPDATE)
- `DELETE /resources/:id` - захищено (DELETE)

---

## 2. Використані пакети та технології

### Основні залежності:

1. **fastify** (^4.25.0) - швидкий веб-фреймворк для Node.js
2. **@fastify/cookie** (^9.3.0) - робота з cookies для зберігання sessionId
3. **@fastify/auth** (^4.5.0) - плагін для автентифікації через preHandler хуки
4. **@fastify/swagger** (^8.13.0) - генерація OpenAPI специфікації
5. **@fastify/swagger-ui** (^2.1.0) - UI для документації API
6. **bcrypt** (^5.1.1) - хешування та перевірка паролів

### Механізми безпеки:

- **Хешування паролів**: використання bcrypt з salt rounds = 10
- **Session-based authentication**: stateful підхід зі збереженням сесій на сервері
- **Cookies**: httpOnly, secure (для HTTPS), sameSite: 'lax'
- **JSON Schema валідація**: автоматична валідація вхідних даних
- **Basic Auth в Nginx**: захист документації на рівні веб-сервера

---

## 3. Принцип роботи Session-Based Authentication

### Процес автентифікації:

1. **Реєстрація**:
   - Користувач надсилає username + password
   - Пароль хешується через bcrypt
   - Користувач зберігається в БД

2. **Вхід (Login)**:
   - Користувач надсилає username + password
   - Система знаходить користувача в БД
   - Перевіряє пароль через bcrypt.compare()
   - Створює нову сесію з унікальним ID
   - Надсилає sessionId в cookie клієнту

3. **Автентифіковані запити**:
   - Клієнт автоматично надсилає cookie з sessionId
   - Middleware `fastify.authenticate` перевіряє:
     - Наявність sessionId в cookies
     - Існування сесії в БД
     - Чи не протермінована сесія
     - Існування користувача
   - Якщо все OK - додає `request.user` та продовжує
   - Інакше - повертає 401 Unauthorized

4. **Вихід (Logout)**:
   - Видаляє сесію з БД
   - Очищає cookie на клієнті

### Налаштування cookies:

```javascript
reply.setCookie('sessionId', session.id, {
  httpOnly: true,      // Недоступний через JavaScript (захист від XSS)
  secure: false,       // true для HTTPS (захист від MITM)
  sameSite: 'lax',     // Захист від CSRF атак
  maxAge: 24 * 60 * 60 // 24 години
});
```

---

## 4. Basic Auth в Nginx

### Налаштування:

1. Генерація файлу `.htpasswd`:
```bash
node generate-htpasswd.js
```

Створює облікові дані:
- Username: `admin`
- Password: `admin123`

2. Конфігурація Nginx (`nginx.conf`):
```nginx
location /docs {
    auth_basic "Restricted Documentation";
    auth_basic_user_file /etc/nginx/.htpasswd;
    
    proxy_pass http://backend;
    ...
}
```

3. При доступі до `/docs` браузер запитує username/password
4. Nginx перевіряє облікові дані перед проксуванням запиту

---

## 5. Тестування

### Запуск сервера:
```bash
npm install
npm start
```

Сервер доступний: http://localhost:3000

### Автоматичне тестування:
```bash
node test-api.js
```

### Ручне тестування через Postman/Insomnia:

#### 1. Реєстрація користувача
```
POST http://localhost:3000/auth/register
Content-Type: application/json

{
  "username": "testuser",
  "password": "password123"
}
```

**Очікуваний результат:**
- Статус: 201 Created
- Відповідь: `{ "id": 1, "username": "testuser", "createdAt": "..." }`

#### 2. Вхід користувача
```
POST http://localhost:3000/auth/login
Content-Type: application/json

{
  "username": "testuser",
  "password": "password123"
}
```

**Очікуваний результат:**
- Статус: 200 OK
- Cookie: `sessionId=...` встановлено
- Відповідь: `{ "message": "Login successful", "user": {...} }`

#### 3. Отримання інформації (з автентифікацією)
```
GET http://localhost:3000/auth/info
Cookie: sessionId=<значення з попереднього запиту>
```

**Очікуваний результат:**
- Статус: 200 OK
- Відповідь: інформація про користувача

#### 4. Спроба доступу без автентифікації
```
POST http://localhost:3000/resources
Content-Type: application/json

{}
```

**Очікуваний результат:**
- Статус: 401 Unauthorized
- Відповідь: `{ "error": "Unauthorized" }`

#### 5. Доступ до захищеного ресурсу
```
POST http://localhost:3000/resources
Cookie: sessionId=<значення>
Content-Type: application/json

{}
```

**Очікуваний результат:**
- Статус: 200 OK
- Відповідь: підтвердження створення ресурсу

#### 6. Вихід
```
POST http://localhost:3000/auth/logout
Cookie: sessionId=<значення>
```

**Очікуваний результат:**
- Статус: 200 OK
- Cookie видалено
- Відповідь: `{ "message": "Logout successful" }`

---

## 6. Труднощі та їх вирішення

### 1. Проблема з better-sqlite3
**Проблема:** Пакет better-sqlite3 вимагає Visual Studio для компіляції нативних модулів.

**Рішення:** Замінено на in-memory базу даних для спрощення та уникнення залежності від нативних модулів. Для production варіанту можна використати PostgreSQL з pg або MongoDB з mongoose.

### 2. Налаштування cookies для різних середовищ
**Проблема:** Атрибут `secure: true` працює тільки з HTTPS.

**Рішення:** Для локальної розробки використовується `secure: false`, для production має бути `secure: true` з SSL сертифікатом.

### 3. CSRF атаки
**Проблема:** Cookie можуть бути вразливі до CSRF атак.

**Рішення:** Використання атрибуту `sameSite: 'lax'` обмежує відправку cookie при міждоменних запитах.

---

## 7. Аналіз переваг і недоліків Session-Based Authentication

### Переваги:

1. **Контроль на сервері**:
   - Можливість миттєвого відкликання доступу
   - Централізоване управління сесіями
   - Можливість відслідковування активних користувачів

2. **Безпека**:
   - Чутлива інформація не передається клієнту
   - Простота ротації сесій
   - Можливість встановлення різних термінів дії

3. **Простота реалізації**:
   - Зрозуміла логіка для початківців
   - Широка підтримка браузерами
   - Автоматичне надсилання cookies

### Недоліки:

1. **Масштабування**:
   - Потребує централізованого сховища (Redis, БД)
   - Складність при горизонтальному масштабуванні
   - Навантаження на сервер для перевірки кожного запиту

2. **Stateful природа**:
   - Сервер має зберігати стан
   - Більше використання пам'яті
   - Складність при розподіленій архітектурі

3. **CORS та мобільні додатки**:
   - Проблеми з cookies при міждоменних запитах
   - Незручність для мобільних додатків
   - Потреба в налаштуванні SameSite, CORS

---

## 8. Порівняння з іншими методами

### Session-Based vs JWT:

| Характеристика | Session-Based | JWT |
|---------------|---------------|-----|
| Тип | Stateful | Stateless |
| Зберігання | Сервер | Клієнт |
| Масштабування | Складніше | Простіше |
| Відкликання | Просте | Складне |
| Розмір | Малий (ID) | Великий (токен) |
| Безпека | Висока | Залежить від реалізації |

### Session-Based vs Basic Auth:

| Характеристика | Session-Based | Basic Auth |
|---------------|---------------|------------|
| Передача даних | Cookie (один раз) | Кожен запит |
| Безпека | Висока | Низька (без HTTPS) |
| Складність | Середня | Проста |
| Функціонал | Повний | Обмежений |

---

## 9. Висновки

Session-Based Authentication є **надійним та зрозумілим** методом для автентифікації в класичних веб-додатках. 

### Коли використовувати:

✅ Класичні веб-додатки (SSR)
✅ Адміністративні панелі
✅ Системи управління контентом
✅ Внутрішні корпоративні додатки
✅ Проекти з високими вимогами до безпеки

### Коли НЕ використовувати:

❌ Мікросервісна архітектура
❌ Mobile-first додатки
❌ SPA з окремим backend
❌ Публічні API для третіх сторін
❌ Системи з екстремальним навантаженням

### Загальний висновок:

В рамках лабораторної роботи було успішно реалізовано:
- ✅ Basic Auth на рівні Nginx для захисту документації
- ✅ Session-Based Authentication з cookies
- ✅ Захист CUD операцій через authentication hooks
- ✅ Валідацію даних через JSON Schema
- ✅ Swagger документацію API

Метод **Session-Based Authentication є оптимальним вибором** для навчальних проектів та традиційних веб-додатків, де важливий контроль над сесіями та високий рівень безпеки.

Для сучасних SPA та мікросервісів краще розглянути JWT або OAuth 2.0, але для розуміння базових принципів автентифікації Session-Based підхід є ідеальним стартом.

---

**Дата виконання:** 24.11.2025
**Студент:** [Ваше ім'я]
**Група:** [Група]
